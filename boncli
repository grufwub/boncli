#!/bin/sh

readonly BONCLI_VERSION=11
readonly BONCLI_GITURL='https://github.com/grufwub/boncli'
readonly BONCLI_GITBRANCH='git-sync'
TEMP_USED=0

usage()
{
	printf 'PLEASE NOTE: you are running bonclay via a wrapper script.
Usage: boncli <COMMAND> <ARGS>

Options:
  --help       Show this screen
  --version    Show boncli script, bonclay and yq binary versions

Commands:
  backup       Backup files/directories to the boncli sync directory
  restore      Restore files/directories to their original location
  sync         Sync files/directories to the boncli sync directory
  config       Open the default configuration file with EDITOR
  manage       Open the CLI file-picker interface to manage your synced files
  update       Check for updates to the boncli script, bonclay and yq binaries
  git          Remotely backup your boncli sync directory with git\n'
}

read_yaml_conf() {
  # read_yaml_conf <PROPERTY>
  local result value

  value=$("$YQ_EXEC" r "$CONF_FILE" "$1")

  [ $value = 'null' ] && value=''

  printf "$value\n"
}

update_yaml_conf() {
  # update_yaml_conf <PROPERTY> <VALUE>
  local result property filecontents

  property=$1
  shift 1

  filecontents=$("$YQ_EXEC" w "$CONF_FILE" "$property" "$*")
  printf '%s\n' "$filecontents" > "$CONF_FILE"
  result=$?

  if [ $result -eq 0 ]; then
    printf 'Updated boncli config property %s: %s\n' "$property" "$*"
  else
    printf 'Error updating boncli config!\n'
  fi

  return $result
}

random_string() {
  # generate random alphanumeric string
  printf "$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w $1 | head -n  1)\n"
}

get_temp_file() {
  local alphanum_str file_str

  # generate file string, touch file, set temp dir used, echo string
  alphanum_str=$(random_string 8)
  file_str="$BONCLI_TEMP/file.$alphanum_str"

  if ( ! touch "$file_str" ); then
    printf 'failed to make temporary file, are BONCLI_ROOT permissions correct?\n'
    return 1
  fi

  TEMP_USED=1
  printf "$file_str\n"
}

get_temp_dir() {
  local alphanum_str dir_str

  # generate file string, touch file, set temp dir used, echo string
  alphanum_str=$(random_string 8)
  dir_str="$BONCLI_TEMP/dir.$alphanum_str"

  if ( ! mkdir -p "$dir_str" > /dev/null 2>&1 ); then
    printf 'failed to make temporary directory, are BONCLI_ROOT permissions correct?\n'
    return 1
  fi

  TEMP_USED=1
  printf "$dir_str\n"
}

file_picker() {
  local args file_contents current_files tmp_file file_results other_confs next_conf

  current_files=$("$YQ_EXEC" r "$CONF_FILE" 'spec' | sed -e 's|:.*$||g' -e "s|~|$HOME|g" | tr '\n' ':' | sed -e 's|:$||g')

  # Launch file picker with correct arguments with pre-selected file list if existent
  tmp_file=$(get_temp_file)
  if [ "$current_files" != '' ]; then
    python3 "$FILE_PICKER" --start-dir "$HOME" --lowest-dir "$HOME" --output "$tmp_file" --pre-selected "$current_files"
  else
    python3 "$FILE_PICKER" --start-dir "$HOME" --lowest-dir "$HOME" --output "$tmp_file"
  fi

  # Receive selected files from results file then remove
  file_results=$(cat "$tmp_file")
  rm -f "$tmp_file"

  # Keep copy of other config settings in memory, then add synced files to this config if found
  other_confs=$("$YQ_EXEC" d "$CONF_FILE" 'spec')
  next_conf=$other_confs
  for path in $file_results ; do
    formatted_entry=$(echo "$path" | sed -e "s|^$HOME/||g")
    formatted_path="~/$formatted_entry"
    next_conf=$(echo "$next_conf" | "$YQ_EXEC" w - "spec.[$formatted_path]" "$SYNC_DIR/$formatted_entry")
  done

  # Write current state of config in memory to bonclay configuration file
  printf '%s\n' "$next_conf" > "$CONF_FILE"
}

setup_env() {
  # Check if boncli directory set, if not use default
  [ -z "$BONCLI_ROOT" ] && BONCLI_ROOT="$HOME/.boncli"

  BONCLI_ROOT="$BONCLI_ROOT"
  SYNC_DIR="$BONCLI_ROOT/sync"
  BINS_DIR="$BONCLI_ROOT/bin"
  BONCLI_TEMP="$BONCLI_ROOT/tmp"
  YQ_EXEC="$BINS_DIR/yq"
  BONCLAY_EXEC="$BINS_DIR/bonclay"
  CONF_FILE="$SYNC_DIR/bonclay.conf.yaml"
  FILE_PICKER="$BINS_DIR/file_picker.py"
  BONCLI_GIT="$BINS_DIR/boncli_git.sh"
}

download() {
  local result

  # download!
  curl -fLo "$1" "$2" > /dev/null 2>&1
  result=$?

  # if failed, print message
  [ $result -ne 0 ] && printf 'download failed\n'

  return $result
}

# https://gist.github.com/lukechilds/a83e1d7127b78fef38c2914c4ececc3c
get_latest_release() {
  curl --silent "https://api.github.com/repos/$1/releases/latest" | # Get latest release from GitHub api
    grep '"tag_name":' |                                            # Get tag line
    sed -E 's/.*"([^"]+)".*/\1/'                                    # Pluck JSON value
}

get_latest_bonclay() {
  local release url tmpdir

  release=$(get_latest_release 'talal/bonclay' | sed -e 's|^v||')
  url="https://github.com/talal/bonclay/releases/download/v$release"

  tmpdir=$(get_temp_dir) || return 1
  cd "$tmpdir" > /dev/null 2>&1

  printf 'downloading latest bonclay (%s)...\n' "v$release"
  case "$(uname -sm)" in
    Darwin\ *64)
      download 'bonclay.tar.gz' "$url/bonclay-$release-darwin_amd64.tar.gz"
      ;;

    Linux\ *64)
      download 'bonclay.tar.gz' "$url/bonclay-$release-linux_amd64.tar.gz"
      ;;

    *)
      printf "no compatible 'bonclay' binary available for your system, exiting...\n"
      exit 1
      ;;
  esac

  result=$?
  if [ $result -eq 0 ]; then
    tar -xf 'bonclay.tar.gz'
    mv 'bonclay' "$BONCLAY_EXEC"
    chmod +x "$BONCLAY_EXEC"
    cd - > /dev/null 2>&1
  fi

  rm -rf "$tmpdir"

  return $result
}

get_latest_yq() {
  local release url tmpdir result

  release=$(get_latest_release 'mikefarah/yq')
  url="https://github.com/mikefarah/yq/releases/download/$release"

  tmpdir=$(get_temp_dir) || return 1
  cd "$tmpdir" > /dev/null 2>&1

  printf 'downloading latest yq (%s)...\n' "$release"
  case "$(uname -sm)" in
    Darwin\ *64)
      download 'yq' "$url/yq_darwin_amd64"
      ;;

    Linux\ *64)
      download 'yq' "$url/yq_linux_amd64"
      ;;

    *)
      printf "no compatible 'yq' binary available for your system, exiting...\n"
      exit 1
      ;;
  esac

  result=$?
  if [ $result -eq 0 ]; then
    mv 'yq' "$YQ_EXEC"
    chmod +x "$YQ_EXEC"
    cd - > /dev/null 2>&1
  fi

  rm -rf "$tmpdir"

  return $result
}

get_latest_file_picker() {
  printf 'downloading latest curses file-picker...\n'
  download "$FILE_PICKER" "$BONCLI_GITURL/raw/$BONCLI_GITBRANCH/scripts/file_picker.py"
  return $?
}

get_latest_boncli_git() {
  printf 'downloading latest bonclay_git.sh script...\n'
  download "$BONCLI_GIT" "$BONCLI_GITURL/raw/$BONCLI_GITBRANCH/scripts/boncli_git.sh"
  return $?
}

update_binaries() {
  local yq_local yq_remote bonclay_local bonclay_remote

  # compare yq local / remote version strings to see if update required
  yq_local=$("$YQ_EXEC" --version | sed -e 's|^[^0-9]*||')
  yq_remote=$(get_latest_release 'mikefarah/yq')

  # handle yq results
  if [ "$yq_local" != "$yq_remote" ]; then
    printf 'yq binary update found!\nlocal:%s remote:%s\n' "$yq_local" "$yq_remote"
    get_latest_yq || return 1
   else
    printf 'yq binary up-to-date!\n'
  fi

  # compare bonclay local / remote version strings to see if update required
  bonclay_local=$("$BONCLAY_EXEC" --version | sed -e 's|^[^0-9]*||')
  bonclay_remote=$(get_latest_release 'talal/bonclay' | sed -e 's|^v||')

  # handle bonclay results
  if [ "$bonclay_local" != "$bonclay_remote" ]; then
    printf 'bonclay binary update found!\nlocal:%s remote:%s\n' "$bonclay_local" "$bonclay_remote"
    get_latest_bonclay || return 1
  else
    printf 'bonclay binary up-to-date!\n'
  fi

  return 0
}

update_boncli() {
  local boncli_remote

  # compare local boncli version to remote, execute update script if version difference
  boncli_remote=$(curl -fL "$BONCLI_GITURL/raw/$BONCLI_GITBRANCH/boncli" --silent)
  if [ $? -ne 0 ]; then
    printf 'error reading boncli version from repository!\n'
    return 1
  fi

  boncli_remote=$(printf "$boncli_remote" | grep -e '^readonly BONCLI_VERSION=' | sed 's|^readonly BONCLI_VERSION=||')
  if [ "$boncli_remote" -gt "$BONCLI_VERSION" ]; then
    printf 'boncli update found! downloading and executing update script...\n'
    curl -fL "$BONCLI_GITURL/raw/$BONCLI_GITBRANCH/scripts/update.sh" --silent | bash

    if [ $? -ne 0 ]; then
      printf 'error downloading boncli update script!\n'
      return 1
    else
      printf '\nboncli updated successfully!\nplease re-run `boncli update` to check for any bonclay / yq binary updates\n'
      return 2
    fi
  else
    printf 'boncli script up-to-date!\n'
    return 0
  fi
}

initial_checks() {
  # ensure that boncli directory exists
  if [ ! -d "$BONCLI_ROOT" ]; then
    printf 'boncli root directory does not exist, creating: %s\n' "$BONCLI_ROOT"
    mkdir -p "$BONCLI_ROOT"
    if [ $? -ne 0 ]; then
      printf 'unable to create '%s'!\nplease check BONCLI_ROOT file permissions and try launching boncli again\n' "$BONCLI_ROOT"
      return 1
    fi
  fi

  # ensure that boncli bins directory exists
  if [ ! -d "$BINS_DIR" ]; then
    mkdir -p "$BINS_DIR"
    if [ $? -ne 0 ]; then
      printf 'unable to create '%s'!\nplease check BONCLI_ROOT file permissions and try launching boncli again\n' "$BINS_DIR"
      return 1
    fi
  fi

  # ensure that boncli sync directory exists
  if [ ! -d "$SYNC_DIR" ]; then
    mkdir -p "$SYNC_DIR"
    if [ $? -ne 0 ]; then
      printf 'unable to create '%s'!\nplease check BONCLI_ROOT file permissions and try launching boncli again\n' "$SYNC_DIR"
      return 1
    fi
  fi

  # ensure that boncli temp directory exists
  if [ ! -d "$BONCLI_TEMP" ]; then
    mkdir -p "$BONCLI_TEMP"
    [ $? -ne 0 ] && ( printf 'unable to create '%s'!\nplease check BONCLI_ROOT file permissions and try launching boncli again\n' "$BONCLI_TEMP"; return 1 )
  fi

  # check that curl installed
  if ( ! curl --version > /dev/null 2>&1 ); then
    printf 'boncli will not function without curl to install binaries and update itself, exiting...\n'
    return 1
  fi

  # check that bonclay bin exists
  if ( ! "$BONCLAY_EXEC" --version > /dev/null 2>&1 ); then
    get_latest_bonclay || return 1
  fi

  # check that yq bin exists
  if ( ! "$YQ_EXEC" --version > /dev/null 2>&1 ); then
    get_latest_yq || return 1
  fi

  # ensure user has python3 installed
  if ( ! python3 --version > /dev/null 2>&1 ); then
    printf 'boncli requires that python3 be installed for the curses file-picker, exiting...\n'
    return 1
  fi

  # check user has file picker script installed
  if [ ! -f "$FILE_PICKER" ]; then
    get_latest_file_picker || return 1
  fi

  # check user has boncli_git.sh script installed
  if [ ! -f "$BONCLI_GIT" ]; then
    get_latest_boncli_git || return 1
  fi

  # initialize configuration file if not already
  if [ ! -f "$CONF_FILE" ]; then
    cd "$SYNC_DIR" > /dev/null 2>&1
    "$BONCLAY_EXEC" init
    printf '\n'
    cd - > /dev/null 2>&1
  fi

  # Returned with no errors!
  return 0
}

main() {
  local result=0

  # Handle arguments
  case "$1" in
    'backup'|'restore'|'sync')
      # Execute bonclay with supplied command and automatically include config file
      "$BONCLAY_EXEC" "$1" "$CONF_FILE"
      result=$?
      ;;

    'config')
      # Provide short-cut to let user modify config file with their environmnetally set EDITOR
      "$EDITOR" "$CONF_FILE"
      result=$?
      ;;

    'manage')
      # Launch the user-friendly Python3 filechecker to select / deselect synchronized files
      file_picker
      result=$?
      ;;

    'git')
      # Launch boncli_git script to handle git synchronization
      shift 1
      . "$BONCLI_GIT" $*
      result=$?
      ;;

    'update')
      # Attempt to update boncli, if up-to-date then update binaries, else return 0 if updated or 1 if failed
      update_boncli; result=$?
      if [ $result -eq 2 ]; then
        return 0
      elif [ $result -eq 1 ]; then
        return 1
      fi

      update_binaries
      result=$?
      ;;

    '--version')
      printf 'boncli version %s\n' "$BONCLI_VERSION"
      "$BONCLAY_EXEC" --version
      "$YQ_EXEC" --version
      result=0
      ;;

    '--help'|*)
      # display usage information
      usage
      result=0
      ;;
  esac

  return $result
}

cleanup() {
  [ $TEMP_USED -eq 1 ] && rm -rf "$BONCLI_TEMP"/*
}

# Set up environment
setup_env

# Only run main if pass initial checks
initial_checks && main $@
result=$?

cleanup

exit $result
